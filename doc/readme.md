## 秒杀业务场景：
### 1 高并发场景：单纯一个tomcat，多线程并发访问，如何解决？
1. 采用synchronized同步锁（独占锁，悲观锁）
2. 采用mysql乐观锁,version或时间戳方式，原理cas(compire and swap)机制
> 面试点，java悲观锁和乐观锁缺点

> java悲观锁缺点
```
1. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
2 一个线程持有锁会导致其它所有需要此锁的线程挂起
3 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
```
> java乐观锁缺点
```$xslt
1 ABA问题，导致数据丢失
解决方式：从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。
这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
2/3（略）               
```
### 2 分布式高并发场景：多个tomcat，多个浏览器同时访问，通过采用synchronized同步锁无法解决，如何用redis锁解决？
尝试的方案，死锁或超卖的场景和解决的方式

1.set锁、执行业务、删除锁
```$xslt
业务异常：业务逻辑抛出异常，锁无法释放，出现死锁
```
2.set锁、try catch中执行业务逻辑，finally删除锁
```$xslt
服务宕机：获取锁的服务删除锁之前宕机，锁无法释放，出现死锁
```
3.set锁、expire设置锁失效时间、try catch中执行业务逻辑，finally删除锁
```$xslt
服务宕机，原子操作：设置锁失效时间之前宕机，锁没有释放，出现死锁，需要set锁和expire失效时间保证原子性
```
4.setnx锁、try catch中执行业务逻辑，finally删除锁
```$xslt
释放别人锁：设置锁失效时间太短，线程A锁执行业务逻辑时，锁失效，线程B获取锁时，线程A此时删除了B的锁，出现超卖
```
5.设置锁的值为唯一码如UUID、setnx锁、try catch中执行业务逻辑，finally通过判断唯一码删除该线程的锁
```$xslt
锁失效：设置锁失效时间太短，线程执行业务逻辑时，锁已经失效，多个线程可以同时执行业务逻辑出现超卖
```
6.获取分布式锁redission、上锁lock（默认时间30s）、finally删除锁unlock
```
redis主从切换：redis主节点set锁、同步从节点，同步前主节点挂掉了，出现超卖
```
> 理论，redission原理和简单介绍源码
```
原理：获取锁的线程会自动续约失效时间、没有获取锁的线程会不断自动重试
源码：lua脚本，获取锁的线程会存hash，key值为"uuid:线程id"，value为线程重入锁次数，根据hash的key值定时续约失效时间
```
> 面试点：秒杀业务，如果加锁前删锁后业务逻辑（查库存、创建订单、扣减库存）耗时20ms，由于redis单线程对同一个商品在一秒内可以下50个订单，如果要下1000个订单，如何优化？
```
看过java里的ConcurrentHashMap的源码和底层原理，应该知道里面的核心思路，就是分段加锁
1 数据库表建20个库存字段如stock01-stock20，或者redis放20个库存的key；
2 写一个随机算法，将1000个请求分配到20个库存段，选择一个进行加锁；
3 当某个库存段为空时，可以自动切换为下一个分段数据去处理；
```
